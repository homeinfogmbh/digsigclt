"""Common functions."""

from functools import wraps
from subprocess import CalledProcessError, check_call
from typing import Callable, Iterable, Sequence

from digsigclt.exceptions import CalledProcessErrors
from digsigclt.types import Command


__all__ = ['command', 'commands']


CommandGenerator = Callable[..., Sequence[str]]
CommandsGenerator = Callable[..., Iterable[Command]]
CommandResult = Callable[..., int | bool]
CommandDecorator = Callable[[CommandGenerator], CommandResult]
CommandsDecorator = Callable[[CommandsGenerator], CommandResult]


def command(*, as_bool: bool = False) -> CommandDecorator:
    """Run the comment generated by function with subprocess.check_call()."""

    def decorator(function: CommandGenerator) -> CommandResult:
        @wraps(function)
        def wrapper(*args, **kwargs) -> int | bool:
            try:
                result = check_call(function(*args, **kwargs))
            except CalledProcessError:
                if as_bool:
                    return False

                raise

            return result == 0 if as_bool else result

        return wrapper

    return decorator


def commands(*, as_bool: bool = False) -> CommandsDecorator:
    """Run a series of commands."""

    def decorator(function: CommandsGenerator) -> CommandResult:
        @wraps(function)
        def wrapper(*args, **kwargs) -> int | bool:
            errors = {}

            for cmd in function(*args, **kwargs):
                try:
                    check_call(cmd.command)
                except CalledProcessError as called_process_error:
                    if called_process_error.returncode not in cmd.exit_ok:
                        if cmd.crucial:
                            errors[cmd] = called_process_error

            if as_bool:
                return not errors

            if errors:
                raise CalledProcessErrors(errors.values())

            return 0

        return wrapper

    return decorator
